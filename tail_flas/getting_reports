import os
import logging
import time
import pythoncom

import xlwings as xw
import pandas as pd
import streamlit as st
from streamlit_autorefresh import st_autorefresh

# ‚Äî‚Äî CONFIG ‚Äî‚Äî
ICE_XLL_PATH = r"C:\path\to\ICE.ExcelAddin64.xll"
REPORTS = {
    "Daily P&L":    20384820,
    "Risk Summary": 20384821,
    # ‚Ä¶ add all 20 report-name ‚Üî report-id pairs ‚Ä¶
}
LOG_FILE = "dashboard.log"

# ‚Äî‚Äî LOGGING SETUP ‚Äî‚Äî
logging.basicConfig(
    filename=LOG_FILE,
    level=logging.INFO,
    format="%(asctime)s %(levelname)s %(message)s"
)

# ‚Äî‚Äî LAUNCH & REGISTER EXCEL (ONE INSTANCE) ‚Äî‚Äî
@st.cache_resource
def get_excel_and_workbook():
    """Start Excel once, register the XLL, and return (app, wb)."""
    pythoncom.CoInitialize()
    try:
        app = xw.App(visible=False)
    except Exception as e:
        logging.exception("Could not start Excel")
        st.error(f"‚ö†Ô∏è Excel startup failed: {e}")
        return None, None

    # Register the ICE add-in
    try:
        if not os.path.isfile(ICE_XLL_PATH):
            raise FileNotFoundError(f"XLL not found: {ICE_XLL_PATH}")
        ok = app.api.RegisterXLL(ICE_XLL_PATH)
        if not ok:
            raise RuntimeError(f"RegisterXLL returned False for {ICE_XLL_PATH}")
    except Exception as e:
        logging.exception("Could not register ICE XLL")
        st.error(f"‚ö†Ô∏è ICE add‚Äëin registration failed: {e}")
        app.kill()
        return None, None

    # Create a blank workbook (we'll populate one sheet per report)
    wb = app.books.add()
    return app, wb

# ‚Äî‚Äî RENDER ALL FORMULAS IN ONE GO ‚Äî‚Äî
def load_all_reports(param: str):
    """
    Writes all 20 =Ice_Report_Legacy(...) array‚Äëformulas into separate sheets,
    fires one Calculate(), then reads them back into st.session_state.data.
    """
    app, wb = get_excel_and_workbook()
    if not app or not wb:
        return {}

    data = {}
    try:
        # 1) Ensure exactly one sheet per report (rename or recreate)
        # Delete extras first
        for sht in wb.sheets:
            sht.delete()
        # Then add one per report
        for name, rid in REPORTS.items():
            sht = wb.sheets.add(name)
            # param cell
            sht.range("C1").value = param
            # array‚Äêformula in A1
            fmla = f'=Ice_Report_Legacy({rid},,C1)'
            sht.range("A1").formula_array = fmla

        # 2) Calculate everything once
        try:
            app.api.CalculateUntilAsyncQueriesDone()
        except Exception:
            app.calculate()
        # give ICE add‚Äëin a moment
        time.sleep(2)

        # 3) Read each sheet‚Äôs UsedRange into a DataFrame
        for name in REPORTS:
            try:
                sht = wb.sheets[name]
                # Expand to include the spill automatically
                df = sht.range("A1").options(pd.DataFrame,
                                            header=1,
                                            index=False,
                                            expand="table").value
                data[name] = df
            except Exception as e:
                logging.exception(f"Failed to read sheet {name}")
                st.error(f"‚ö†Ô∏è Could not read report **{name}**: {e}")
                data[name] = pd.DataFrame()

    except Exception as e:
        logging.exception("Error during load_all_reports")
        st.error(f"üö® Unexpected error fetching reports: {e}")

    return data

# ‚Äî‚Äî STREAMLIT APP ‚Äî‚Äî
def main():
    st.set_page_config(page_title="ICE Dashboard", layout="wide")
    st.title("üìä Live ICE Reports Dashboard")

    # Auto‚Äërefresh every 5 min
    refresh = st_autorefresh(interval=300_000, key="refresh")

    param = st.text_input("Parameter for $C$1", "")

    if "data" not in st.session_state or refresh:
        with st.spinner("Fetching all reports‚Ä¶"):
            st.session_state.data = load_all_reports(param)

    # Display them
    for name, df in st.session_state.data.items():
        st.subheader(name)
        if df is None or df.empty:
            st.warning(f"No data for **{name}**")
        else:
            st.dataframe(df, use_container_width=True)

if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        logging.exception("Unhandled error in Streamlit")
        st.error(f"üí• Fatal error: {e}")
