import streamlit as st
import pandas as pd
import numpy as np
import os
import glob
import re
from datetime import datetime, timedelta
from bokeh.plotting import figure
from bokeh.models import HoverTool, ColumnDataSource, NumeralTickFormatter
from st_aggrid import AgGrid, GridOptionsBuilder, JsCode

# --- Page Configuration and Styling ---
st.set_page_config(
    page_title="Tail Analysis Dashboard",
    page_icon="ÔøΩ",
    layout="wide",
    initial_sidebar_state="expanded",
)

# Custom CSS for AgGrid theming and alignment
st.markdown("""
<style>
    body {
        background-color: #F0F2F6;
    }
    .ag-header-cell-label, .ag-cell {
        justify-content: center !important;
        text-align: center !important;
        font-size: 0.85rem !important; /* Smaller font size */
    }
    .metric-card {
        background-color: #FFFFFF;
        border-left: 5px solid #0068C9;
        padding: 1rem;
        border-radius: 5px;
        box-shadow: 0 2px 4px 0 rgba(0,0,0,0.1);
    }
    /* Group Header Styling to match screenshot */
    .ag-header-group-cell {
        font-weight: bold;
        border-right: 1px solid #BDC3C7;
    }
    .header-group-cob .ag-header-group-cell-label { background-color: #DDEBF7 !important; color: #2F528F !important; }
    .header-group-prevcob .ag-header-group-cell-label { background-color: #E2F0D9 !important; color: #385723 !important; }
    .header-group-diff .ag-header-group-cell-label { background-color: #FCE4D6 !important; color: #C65911 !important; }

    /* Row highlighting styles */
    .ag-row-negative { background-color: #FFEBEE !important; }
    .ag-row-positive { background-color: #E8F5E9 !important; }

    /* --- Dark Mode Overrides --- */
    .stApp[data-theme="dark"] {
        background-color: #0E1117;
    }
    [data-theme="dark"] .metric-card {
        background-color: #1E2128;
        border-left: 5px solid #00A3FF;
    }
    [data-theme="dark"] .ag-theme-streamlit {
        background-color: #1E2128;
        color: #FAFAFA;
    }
    [data-theme="dark"] .ag-header-group-cell {
        border-right: 1px solid #444;
    }
    [data-theme="dark"] .header-group-cob .ag-header-group-cell-label { background-color: #1E3A5F !important; color: #DDEBF7 !important; }
    [data-theme="dark"] .header-group-prevcob .ag-header-group-cell-label { background-color: #2F4B37 !important; color: #E2F0D9 !important; }
    [data-theme="dark"] .header-group-diff .ag-header-group-cell-label { background-color: #5E3C2F !important; color: #FCE4D6 !important; }
    [data-theme="dark"] .ag-row-negative { background-color: #401A1A !important; }
    [data-theme="dark"] .ag-row-positive { background-color: #1A401A !important; }
</style>
""", unsafe_allow_html=True)

# --- MOCK DATA GENERATION ---
def create_mock_excel_file(path, file_date):
    """Generates a mock Excel file with the specified structure."""
    if os.path.exists(path):
        return

    writer = pd.ExcelWriter(path, engine='openpyxl')
    nodes = {10: "FX", 22194: "Rates", 1373254: "EM Macro"}
    sensitivity_types = ["IR Delta SABR", "EQ Delta", "IR Delta Normal Backbone", "FX Vega"]
    currencies = ["USD", "EUR", "GBP", "AUD", "JPY"]
    
    dvar_vectors = range(261, 522)
    svar_vectors = range(1, 261)

    for sheet_name_base in ["DVaR_COB", "DVaR_Prev_COB"]:
        df_data = []
        for i in range(300): 
            node = np.random.choice(list(nodes.keys()))
            df_data.append({
                "Var Type": "DVaR", "Node": node, "Asset class": nodes[node], "currency": np.random.choice(currencies),
                "sensitivity_type": np.random.choice(sensitivity_types), "load_code": f"LC{np.random.randint(1000, 9999)}",
                **{f"pnl_vector{v}{'[T-2]' if 'Prev' in sheet_name_base else ''}": np.random.uniform(-5e5, 5e5) for v in dvar_vectors}
            })
        df = pd.DataFrame(df_data)
        date_header_row = [np.nan] * 6 + list(pd.to_datetime([file_date - timedelta(days=i*2) for i in range(len(dvar_vectors))]).strftime('%d-%m-%Y'))
        header_df = pd.DataFrame([date_header_row])
        header_df.to_excel(writer, sheet_name=sheet_name_base, index=False, header=False)
        df.to_excel(writer, sheet_name=sheet_name_base, index=False, startrow=1)

    for sheet_name_base in ["SVaR_COB", "SVaR_Prev_COB"]:
        df_data = []
        for i in range(300):
            node = np.random.choice(list(nodes.keys()))
            df_data.append({
                "Var Type": "SVaR", "Node": node, "Asset class": nodes[node], "currency": np.random.choice(currencies),
                "sensitivity_type": np.random.choice(sensitivity_types), "load_code": f"LC{np.random.randint(1000, 9999)}",
                **{f"pnl_vector{v}{'[T-2]' if 'Prev' in sheet_name_base else ''}": np.random.uniform(-1e6, 1e6) for v in svar_vectors}
            })
        df = pd.DataFrame(df_data)
        date_header_row = [np.nan] * 6 + list(pd.to_datetime([file_date - timedelta(days=i*3) for i in range(len(svar_vectors))]).strftime('%d-%m-%Y'))
        header_df = pd.DataFrame([date_header_row])
        header_df.to_excel(writer, sheet_name=sheet_name_base, index=False, header=False)
        df.to_excel(writer, sheet_name=sheet_name_base, index=False, startrow=1)

    writer.close()
    st.info(f"Created a mock data file: {os.path.basename(path)}")


# --- Data Loading and Processing ---
@st.cache_data
def process_data_file(file_path):
    """
    Main function to process the selected Excel file. Reads all sheets, performs
    aggregations, and creates all final dataframes exactly as specified.
    """
    def read_sheet(sheet_name):
        try:
            date_map_df = pd.read_excel(file_path, sheet_name=sheet_name, nrows=1, header=None)
            raw_df = pd.read_excel(file_path, sheet_name=sheet_name, header=1)
            date_map = dict(zip(raw_df.columns, date_map_df.iloc[0]))
            pnl_cols = [col for col in raw_df.columns if 'pnl_vector' in str(col)]
            return raw_df, date_map, pnl_cols
        except Exception as e:
            st.error(f"Could not read sheet '{sheet_name}'. Error: {e}")
            return None, None, None

    def create_summary_df(sheet_name, node_map={10: "FX", 22194: "Rates", 1373254: "EM Macro"}):
        raw_df, date_map, pnl_vectors = read_sheet(sheet_name)
        if raw_df is None: return None
        
        all_results = []
        for pnl_col in pnl_vectors:
            fx_sum = raw_df.loc[raw_df['Node'] == 10, pnl_col].sum()
            rates_sum = raw_df.loc[raw_df['Node'] == 22194, pnl_col].sum()
            em_macro_sum = raw_df.loc[raw_df['Node'] == 1373254, pnl_col].sum()
            result_row = {
                'Pnl_Vector': pnl_col, 'FX': fx_sum, 'Rates': rates_sum,
                'EM Macro': em_macro_sum, 'Macro': fx_sum + rates_sum + em_macro_sum,
                'Date': date_map.get(pnl_col)
            }
            all_results.append(result_row)

        if not all_results: return pd.DataFrame()
        final_df = pd.DataFrame(all_results)
        final_df["P&L Vector No"] = final_df["Pnl_Vector"].str.extract(r'(\d+)').astype(int)
        final_df['Value Rank'] = final_df['Macro'].rank(method='first', ascending=True).astype(int)
        final_df.drop_duplicates(subset=['P&L Vector No'], keep='first', inplace=True)
        return final_df

    dvar_cob_df = create_summary_df("DVaR_COB")
    dvar_prev_cob_df = create_summary_df("DVaR_Prev_COB")
    svar_cob_df = create_summary_df("SVaR_COB")
    svar_prev_cob_df = create_summary_df("SVaR_Prev_COB")

    if any(df is None for df in [dvar_cob_df, dvar_prev_cob_df, svar_cob_df, svar_prev_cob_df]): return None

    def create_top_20_comparison_df(cob_df, prev_cob_df):
        top_20_neg = cob_df.sort_values("Macro", ascending=True).head(20).copy()
        top_20_pos = cob_df.sort_values("Macro", ascending=False).head(20).copy()
        
        top_20_neg['COB Rank'] = range(1, len(top_20_neg) + 1)
        top_20_pos['COB Rank'] = range(260, 260 - len(top_20_pos), -1)

        combined_top = pd.concat([top_20_neg, top_20_pos])
        comparison = pd.merge(combined_top, prev_cob_df, on="Date", how="left", suffixes=('_COB', '_PrevCOB'))
        
        for col in ["Macro", "Rates", "FX", "EM Macro"]:
            if f'{col}_COB' in comparison.columns and f'{col}_PrevCOB' in comparison.columns:
                 comparison[f'Diff_{col}'] = comparison[f'{col}_COB'] - comparison[f'{col}_PrevCOB']
        
        final_df = pd.DataFrame()
        final_df["COB_Rank"] = comparison["COB Rank"]
        final_df["COB_PNL_Vector_No"] = comparison["P&L Vector No_COB"]
        final_df["Date"] = pd.to_datetime(comparison["Date"], errors='coerce').dt.strftime('%d %b %Y')
        final_df["COB_Macro"] = comparison.get("Macro_COB") / 1_000_000
        final_df["COB_Rates"] = comparison.get("Rates_COB") / 1_000_000
        final_df["COB_FX"] = comparison.get("FX_COB") / 1_000_000
        final_df["COB_EM_Macro"] = comparison.get("EM Macro_COB") / 1_000_000
        final_df["Prev_Cob_Rank"] = comparison.get("Value Rank_PrevCOB")
        final_df["Prev_PNL_Vector_No"] = comparison.get("P&L Vector No_PrevCOB")
        final_df["Prev_Macro"] = comparison.get("Macro_PrevCOB") / 1_000_000
        final_df["Prev_Rates"] = comparison.get("Rates_PrevCOB") / 1_000_000
        final_df["Prev_FX"] = comparison.get("FX_PrevCOB") / 1_000_000
        final_df["Prev_EM_Macro"] = comparison.get("EM Macro_PrevCOB") / 1_000_000
        final_df["Diff_Macro"] = comparison.get("Diff_Macro") / 1_000_000
        final_df["Diff_Rates"] = comparison.get("Diff_Rates") / 1_000_000
        final_df["Diff_FX"] = comparison.get("Diff_FX") / 1_000_000
        final_df["Diff_EM_Macro"] = comparison.get("Diff_EM Macro") / 1_000_000

        return final_df.sort_values(by="COB_Rank").reset_index(drop=True)

    def create_top_changes_df(cob_df, prev_cob_df):
        merged_df = pd.merge(cob_df, prev_cob_df, on="P&L Vector No", how="inner", suffixes=('_COB', '_PrevCOB'))
        if merged_df.empty: return pd.DataFrame() 
        
        merged_df['Diff'] = merged_df['Macro_COB'] - merged_df['Macro_PrevCOB']
        
        top_20_neg_changes = merged_df.sort_values("Diff", ascending=True).head(20)
        top_20_pos_changes = merged_df.sort_values("Diff", ascending=False).head(20)
        
        combined_changes = pd.concat([top_20_neg_changes, top_20_pos_changes])
        if combined_changes.empty: return pd.DataFrame()

        combined_changes['Final_Rank'] = list(range(1, len(top_20_neg_changes) + 1)) + list(range(1, len(top_20_pos_changes) + 1))
        
        final_df = pd.DataFrame()
        final_df["Rank"] = combined_changes["Final_Rank"]
        final_df["COB_PNL_Vector_No"] = combined_changes["P&L Vector No"]
        final_df["Prev_PNL_Vector_No"] = combined_changes["P&L Vector No"]
        final_df["Date"] = pd.to_datetime(combined_changes["Date_COB"], errors='coerce').dt.strftime('%d %b %Y')
        final_df["Macro_COB"] = combined_changes["Macro_COB"] / 1_000_000
        final_df["Macro_PrevCob"] = combined_changes["Macro_PrevCOB"] / 1_000_000
        final_df["Diff"] = combined_changes["Diff"] / 1_000_000
        final_df["Rates"] = combined_changes["Rates_COB"] / 1_000_000
        final_df["FX"] = combined_changes["FX_COB"] / 1_000_000
        final_df["EM_Macro"] = combined_changes["EM Macro_COB"] / 1_000_000
        
        return final_df

    data_dict = {
        "dvar_cob": dvar_cob_df, "svar_cob": svar_cob_df,
        "dvar_prev_cob": dvar_prev_cob_df, "svar_prev_cob": svar_prev_cob_df
    }
    data_dict["dvar_comparison"] = create_top_20_comparison_df(dvar_cob_df, dvar_prev_cob_df)
    data_dict["svar_comparison"] = create_top_20_comparison_df(svar_cob_df, svar_prev_cob_df)
    data_dict["dvar_changes"] = create_top_changes_df(dvar_cob_df, dvar_prev_cob_df)
    data_dict["svar_changes"] = create_top_changes_df(svar_cob_df, svar_prev_cob_df)

    return data_dict

# --- UI Rendering Functions ---
def display_aggrid(df, is_comparison=False, is_changes=False):
    """Configures and displays a dataframe with Streamlit AgGrid."""
    if df is None or df.empty:
        st.warning("Data not available or no matching records found.")
        return
        
    cells_renderer = JsCode("""
    class BlackRedCellRenderer {
        init(params) {
            this.eGui = document.createElement('div');
            const formattedValue = params.value != null ? params.value.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2}) : '';
            if (params.value < 0) {
                this.eGui.innerHTML = `<span style="color: red; font-weight: 500;">${formattedValue}</span>`;
            } else {
                 this.eGui.innerHTML = `<span style="color: black;">${formattedValue}</span>`;
            }
        }
        getGui() { return this.eGui; }
    }
    """)
    
    # Define column groups and properties
    if is_comparison:
        column_defs = [
            {
                "headerName": "COB", "headerClass": "header-group-cob",
                "children": [
                    {"field": "COB_Rank", "headerName": "COB\nRank", "width": 70},
                    {"field": "COB_PNL_Vector_No", "headerName": "COB P&L\nVector No", "width": 100},
                    {"field": "Date", "width": 110},
                    {"field": "COB_Macro", "headerName": "Macro", "cellRenderer": cells_renderer, "width": 100},
                    {"field": "COB_Rates", "headerName": "Rates", "cellRenderer": cells_renderer, "width": 100},
                    {"field": "COB_FX", "headerName": "FX", "cellRenderer": cells_renderer, "width": 100},
                    {"field": "COB_EM_Macro", "headerName": "EM Macro", "cellRenderer": cells_renderer, "width": 100},
                ]
            },
            {
                "headerName": "PrevCOB", "headerClass": "header-group-prevcob",
                "children": [
                    {"field": "Prev_Cob_Rank", "headerName": "Prev Cob\nRank", "width": 90},
                    {"field": "Prev_PNL_Vector_No", "headerName": "Prev COB\nP&L Vector No", "width": 110},
                    {"field": "Prev_Macro", "headerName": "Macro", "cellRenderer": cells_renderer, "width": 100},
                    {"field": "Prev_Rates", "headerName": "Rates", "cellRenderer": cells_renderer, "width": 100},
                    {"field": "Prev_FX", "headerName": "FX", "cellRenderer": cells_renderer, "width": 100},
                    {"field": "Prev_EM_Macro", "headerName": "EM Macro", "cellRenderer": cells_renderer, "width": 100},
                ]
            },
            {
                "headerName": "Difference", "headerClass": "header-group-diff",
                "children": [
                    {"field": "Diff_Macro", "headerName": "Macro", "cellRenderer": cells_renderer, "width": 100},
                    {"field": "Diff_Rates", "headerName": "Rates", "cellRenderer": cells_renderer, "width": 100},
                    {"field": "Diff_FX", "headerName": "FX", "cellRenderer": cells_renderer, "width": 100},
                    {"field": "Diff_EM_Macro", "headerName": "EM Macro", "cellRenderer": cells_renderer, "width": 100},
                ]
            }
        ]
    else: # For Top Changes table
        gb = GridOptionsBuilder.from_dataframe(df)
        gb.configure_column("Date", width=110)
        gb.configure_column("Rank", width=70)
        for col in df.columns:
            if df[col].dtype in ['float64', 'int64'] and col not in ["Rank", "COB P&L Vector No", "Prev COB P&L Vector No"]:
                gb.configure_column(col, cellRenderer=cells_renderer)
        column_defs = gb.build()['columnDefs']

    # FIX: Add getRowStyle for row highlighting on both table types
    getRowStyle_js = JsCode("""
        function(params) {
            let valueToCheck;
            if (params.data.Diff !== undefined) {
                // This is the Top Changes table
                valueToCheck = params.data.Diff;
            } else {
                // This is the Top Comparison table
                valueToCheck = params.data.COB_Macro;
            }

            if (valueToCheck < 0) {
                return { 'background-color': '#FFEBEE' };
            }
            // In comparison table, we highlight positives too. In changes, diff > 0 is a positive change.
            if (valueToCheck > 0) {
                return { 'background-color': '#E8F5E9' };
            }
        }
    """)
    
    gridOptions = {
        "columnDefs": column_defs,
        "defaultColDef": {
            "resizable": True, "sortable": True, "filter": False,
            "wrapHeaderText": True, "autoHeaderHeight": True
        },
        "domLayout": 'autoHeight',
        "suppressMenuHide": True,
        "getRowStyle": getRowStyle_js,
    }

    AgGrid(
        df, gridOptions=gridOptions, width='100%',
        theme='streamlit', allow_unsafe_jscode=True
    )

def create_bokeh_chart(cob_df, prev_cob_df, title, asset_class='Macro'):
    """Creates a chart for the selected asset class."""
    if cob_df is None or prev_cob_df is None or cob_df.empty or prev_cob_df.empty:
        p = figure(height=400, title=f"{title} - No Data Available", sizing_mode="stretch_width")
        return p
        
    # FIX: Sanitize column names by replacing spaces for Bokeh compatibility
    cob_df.columns = cob_df.columns.str.replace(' ', '_')
    prev_cob_df.columns = prev_cob_df.columns.str.replace(' ', '_')
    asset_class_sanitized = asset_class.replace(' ', '_')
    
    source_df = pd.merge(cob_df, prev_cob_df, on='P&L_Vector_No', how="inner", suffixes=('_COB', '_PrevCOB'))
    if source_df.empty:
        p = figure(height=400, title=f"{title} - No Matching P&L Vectors to Compare", sizing_mode="stretch_width")
        return p
        
    source_df['Date_COB_dt'] = pd.to_datetime(source_df['Date_COB'], errors='coerce')
    source = ColumnDataSource(source_df)
    
    p = figure(height=400, x_axis_label="P&L Vector No", y_axis_label="Value", title=f"{title}: {asset_class}", sizing_mode="stretch_width", tools="pan,wheel_zoom,box_zoom,reset,save")
    p.yaxis.formatter = NumeralTickFormatter(format="0,0.00a")
    
    # Plot the selected asset class using sanitized names
    p.line(x='P&L_Vector_No', y=f'{asset_class_sanitized}_COB', source=source, legend_label=f"{asset_class} COB", color="dodgerblue", width=2.5, alpha=0.8)
    p.circle(x='P&L_Vector_No', y=f'{asset_class_sanitized}_COB', source=source, legend_label=f"{asset_class} COB", color="dodgerblue", size=5)
    p.line(x='P&L_Vector_No', y=f'{asset_class_sanitized}_PrevCOB', source=source, legend_label=f"{asset_class} PrevCOB", color="gray", width=2, line_dash="dashed")
    
    hover = HoverTool(tooltips=[
        ("P&L Vector", "@{P&L_Vector_No}"), 
        ("Date", "@Date_COB_dt{%F}"), 
        (f"{asset_class} COB", f"@{asset_class_sanitized}_COB{{0,0}}"), 
        (f"{asset_class} PrevCOB", f"@{asset_class_sanitized}_PrevCOB{{0,0}}")
    ], formatters={'@Date_COB_dt': 'datetime'})
    p.add_tools(hover)
    p.legend.location = "top_left"
    p.legend.click_policy = "hide"
    return p

# --- MAIN APP ---
def main():
    st.title("üìä Tail Analysis Dashboard")
    st.write("""
    An interactive web application to analyze daily DVaR and SVaR tail events.
    **Installation Note:** This app requires `streamlit-aggrid`. Please install it using: `pip install streamlit-aggrid`
    """)
    DATA_FOLDER_PATH = r"C:\Top tails daily run data"
    
    st.sidebar.title("Controls")
    st.sidebar.markdown("---")
    debug_mode = st.sidebar.checkbox("Show Debug Info")
    
    if not os.path.exists(DATA_FOLDER_PATH):
        st.warning(f"Folder not found: '{DATA_FOLDER_PATH}'. Creating it now.")
        os.makedirs(DATA_FOLDER_PATH)
        
    files = glob.glob(os.path.join(DATA_FOLDER_PATH, "Tail_analysis_auto_*.xlsx"))
    if not files:
        st.sidebar.warning("No data files found. A mock file will be created for demonstration.")
        today = datetime.now()
        mock_file_name = f"mock_Tail_analysis_auto_{today.strftime('%d_%b_%Y')}.xlsx"
        mock_file_path = os.path.join(DATA_FOLDER_PATH, mock_file_name)
        create_mock_excel_file(mock_file_path, today)
        files = glob.glob(os.path.join(DATA_FOLDER_PATH, "Tail_analysis_auto_*.xlsx"))
        
    file_map = {os.path.basename(f): f for f in files}
    selected_file_name = st.sidebar.selectbox("Select a Report File", sorted(file_map.keys(), reverse=True))

    if selected_file_name:
        selected_file_path = file_map[selected_file_name]
        st.sidebar.success(f"Loaded: **{selected_file_name}**")
        data = process_data_file(selected_file_path)

        if data:
            if debug_mode:
                st.subheader("üêõ Debug Information")
                for name, df in data.items():
                    if df is not None:
                        st.markdown(f"**DataFrame: `{name}`** (Shape: {df.shape})")
                        st.dataframe(df.head())
                    else:
                        st.markdown(f"**DataFrame: `{name}`** (is None)")
                st.markdown("---")

            asset_classes = ["Macro", "FX", "Rates", "EM Macro"]
            dvar_tab, svar_tab = st.tabs(["DVaR Analysis", "SVaR Analysis"])
            with dvar_tab:
                st.header("DVaR Analysis")
                worst_dvar = data["dvar_cob"].sort_values("Macro").iloc[0]
                st.markdown('<div class="metric-card">', unsafe_allow_html=True)
                st.metric(
                    label=f"Worst DVaR | Date: {pd.to_datetime(worst_dvar['Date']).strftime('%d %b %Y')} | P&L Vector: {worst_dvar['P&L Vector No']}",
                    value=f"{worst_dvar['Macro']/1_000_000:.2f}M"
                )
                st.markdown('</div>', unsafe_allow_html=True)
                st.write("") 

                chart_tab, comparison_tab, changes_tab = st.tabs(["üìà Time Series Chart", "üèÜ Top 20 Comparison", "üîÑ Top Changes"])
                with chart_tab:
                    selected_asset_class_dvar = st.selectbox("Select Asset Class for Chart", asset_classes, key="dvar_asset_class")
                    st.bokeh_chart(create_bokeh_chart(data["dvar_cob"], data["dvar_prev_cob"], "DVaR", asset_class=selected_asset_class_dvar), use_container_width=True)
                with comparison_tab: 
                    st.subheader("Top 20 Positive & Negative DVaR Macro Values")
                    st.info("All values are in millions.")
                    display_aggrid(data['dvar_comparison'], is_comparison=True)
                with changes_tab: 
                    st.subheader("Top 20 Largest DVaR Macro Changes (COB vs PrevCOB)")
                    st.info("All values are in millions.")
                    display_aggrid(data['dvar_changes'], is_changes=True)
            with svar_tab:
                st.header("SVaR Analysis")
                worst_svar = data["svar_cob"].sort_values("Macro").iloc[0]
                st.markdown('<div class="metric-card">', unsafe_allow_html=True)
                st.metric(
                    label=f"Worst SVaR | Date: {pd.to_datetime(worst_svar['Date']).strftime('%d %b %Y')} | P&L Vector: {worst_svar['P&L Vector No']}",
                    value=f"{worst_svar['Macro']/1_000_000:.2f}M"
                )
                st.markdown('</div>', unsafe_allow_html=True)
                st.write("") 

                chart_tab, comparison_tab, changes_tab = st.tabs(["üìà Time Series Chart", "üèÜ Top 20 Comparison", "üîÑ Top Changes"])
                with chart_tab: 
                    selected_asset_class_svar = st.selectbox("Select Asset Class for Chart", asset_classes, key="svar_asset_class")
                    st.bokeh_chart(create_bokeh_chart(data["svar_cob"], data["svar_prev_cob"], "SVaR", asset_class=selected_asset_class_svar), use_container_width=True)
                with comparison_tab: 
                    st.subheader("Top 20 Positive & Negative SVaR Macro Values")
                    st.info("All values are in millions.")
                    display_aggrid(data['svar_comparison'], is_comparison=True)
                with changes_tab: 
                    st.subheader("Top 20 Largest SVaR Macro Changes (COB vs PrevCOB)")
                    st.info("All values are in millions.")
                    display_aggrid(data['svar_changes'], is_changes=True)
    else: st.error("No data files could be found or created. Please check the folder path.")

if __name__ == "__main__":
    main()
ÔøΩ
