import dash
from dash import html, dcc, Input, Output, State, dash_table
import dash_bootstrap_components as dbc
import sqlite3
import pandas as pd

DB_PATH = "historical_data.db"

def get_distinct_cob_dates(table_name):
    """Return a sorted list of distinct COB dates from the given table."""
    conn = sqlite3.connect(DB_PATH)
    query = f"SELECT DISTINCT cob_date FROM {table_name} ORDER BY cob_date"
    dates = pd.read_sql(query, conn)["cob_date"].tolist()
    conn.close()
    return dates

def get_data_for_cob_date(cob_date, table_name):
    """Fetch data from the specified table for the given COB date."""
    conn = sqlite3.connect(DB_PATH)
    query = f"SELECT * FROM {table_name} WHERE cob_date = '{cob_date}'"
    df = pd.read_sql(query, conn)
    conn.close()
    return df

def indent_node_name(name, level):
    """
    Prepend non‑breaking spaces to Node Name based on Node Level.
    For example, if Node Level is 3 then 4 spaces, if 4 then 8, if 5 then 12, etc.
    """
    try:
        level_int = int(level)
    except (ValueError, TypeError):
        level_int = 0
    if level_int >= 3:
        indent_count = (level_int - 2) * 4  # level 3 -> 4 spaces, level 4 -> 8, etc.
        return "&nbsp;" * indent_count + name
    return name

# Preload COB dates from one table
initial_dates = get_distinct_cob_dates("Sheet1_data_alloc")
dropdown_options = [{"label": d, "value": d} for d in initial_dates]

# Use a Bootstrap theme (Flatly for light mode by default)
external_stylesheets = [dbc.themes.FLATLY]
app = dash.Dash(__name__, external_stylesheets=external_stylesheets)

def generate_datatable(df, theme):
    """
    Return a DataTable with:
      • Conditional formatting: negative numbers red, positive numbers black.
      • A row hover effect via custom CSS.
      • The "Node Name" column rendered as markdown (to allow HTML) and left‑aligned.
    """
    # Theme-specific styles.
    if theme == "dark":
        header_style = {"backgroundColor": "#343a40", "color": "white", "fontWeight": "bold"}
        cell_style = {"backgroundColor": "#212529", "color": "white", "textAlign": "center", "padding": "5px"}
    else:
        header_style = {"backgroundColor": "#0074D9", "color": "white", "fontWeight": "bold"}
        cell_style = {"backgroundColor": "white", "color": "black", "textAlign": "center", "padding": "5px"}
    
    # For numeric columns, apply conditional formatting so negatives appear red.
    numeric_columns = [col for col in df.columns if col not in ["Node Name", "Node ID", "Node Level", "cob_date"]]
    negative_style = [
        {
            'if': {
                'filter_query': '{{{}}} < 0'.format(col),
                'column_id': col
            },
            'color': 'red'
        } for col in numeric_columns
    ]
    
    # Build the columns list; for "Node Name" use markdown presentation.
    columns = [
        {"name": col, "id": col, **({"presentation": "markdown"} if col == "Node Name" else {})}
        for col in df.columns
    ]
    
    # Force left alignment for the "Node Name" column.
    style_cell_conditional = [{"if": {"column_id": "Node Name"}, "textAlign": "left"}]
    
    return dash_table.DataTable(
        data=df.to_dict("records"),
        columns=columns,
        sort_action="native",
        style_table={"overflowX": "auto"},
        style_header=header_style,
        style_cell=cell_style,
        style_cell_conditional=style_cell_conditional,
        style_data_conditional=negative_style,
        page_size=10
    )

# Create a modern navbar with a theme toggle placed inside an HTML Div.
navbar = dbc.Navbar(
    dbc.Container([
        dbc.NavbarBrand("Modern Dashboard", className="ms-2"),
        dbc.Nav(
            [dbc.NavItem(dbc.NavLink("Home", href="#"))],
            className="me-auto", navbar=True
        ),
        # Instead of NavbarText, wrap the theme toggle in an html.Div
        html.Div(
            dcc.RadioItems(
                id="theme-selector",
                options=[
                    {"label": "Light Mode", "value": "light"},
                    {"label": "Dark Mode", "value": "dark"}
                ],
                value="light",
                inline=True,
                labelStyle={'margin-right': '10px'}
            ),
            className="ms-auto"
        )
    ]),
    color="primary",
    dark=True,
    sticky="top"
)

# Layout body with a dropdown and button.
body = dbc.Container([
    dbc.Row(
        dbc.Col(
            dbc.Card([
                dbc.CardBody([
                    dbc.Row([
                        dbc.Col([
                            dbc.Label("Select COB Date:", className="fw-bold"),
                            dcc.Dropdown(id="cob-dropdown", options=dropdown_options, placeholder="Select a COB date")
                        ], width=6)
                    ]),
                    dbc.Row(
                        dbc.Col(
                            dbc.Button("Show Dashboard", id="show-button", color="primary", className="mt-3"),
                            width={"size": 2, "offset": 5}
                        )
                    )
                ])
            ], className="my-4")
        )
    ),
    dbc.Row(
        dbc.Col(
            html.Div(id="dashboard-container")
        )
    )
], fluid=True)

# Inject custom CSS for row hover effect in the DataTable.
custom_css = html.Style("""
/* Hover effect for DataTable rows */
.dash-table-container .dash-spreadsheet tr:hover {
  background-color: rgba(0,123,255,0.2) !important;
}
""")

# Set the final layout.
app.layout = html.Div([navbar, custom_css, body])

# Callback: When a COB date is selected and "Show Dashboard" is clicked.
@app.callback(
    Output("dashboard-container", "children"),
    [Input("show-button", "n_clicks")],
    [State("cob-dropdown", "value"),
     State("theme-selector", "value")]
)
def update_dashboard(n_clicks, selected_cob, theme):
    if n_clicks and selected_cob:
        df_alloc = get_data_for_cob_date(selected_cob, "Sheet1_data_alloc")
        df_stand = get_data_for_cob_date(selected_cob, "Sheet1_data_stand")
        
        # Update the "Node Name" column in both DataFrames with indentation based on Node Level.
        def indent_row(row):
            try:
                level = int(row["Node Level"])
            except (ValueError, TypeError):
                level = 0
            # For level 3: 4 spaces, level 4: 8, level 5: 12, level 6: 16, level 7: 20, level 8: 24.
            if level >= 3:
                indent_count = (level - 2) * 4
                return "&nbsp;" * indent_count + row["Node Name"]
            return row["Node Name"]
        
        if not df_alloc.empty:
            df_alloc["Node Name"] = df_alloc.apply(indent_row, axis=1)
        if not df_stand.empty:
            df_stand["Node Name"] = df_stand.apply(indent_row, axis=1)
        
        table_alloc = generate_datatable(df_alloc, theme)
        table_stand = generate_datatable(df_stand, theme)
        
        return html.Div([
            html.H4(f"Sheet1_data_alloc for COB Date: {selected_cob}", className="my-3 text-center"),
            table_alloc,
            html.H4(f"Sheet1_data_stand for COB Date: {selected_cob}", className="my-3 text-center"),
            table_stand
        ])
    return html.Div("Please select a COB date and click 'Show Dashboard'.", className="text-center")

if __name__ == "__main__":
    app.run_server(debug=True)